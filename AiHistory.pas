UNIT AiHistory;

INTERFACE

USES
  System.SysUtils, System.Generics.Collections, LightCore.StreamBuff2;

TYPE
  // Enum to differentiate between text and file data parts in chat history
  TChatType = (cptUnknown, cptText, cptFileData);
  TChatRole = (crUnknown,
               crUser,     // Represents input from the human user (e.g., prompts, questions, or messages). The model treats this as new information to respond to.
               crModel);   // Represents previous responses generated by the Gemini model itself. This allows maintaining conversation context by including the model's own prior outputs.


  // Represents a single part of a chat message (text or file)
  TChatPart = class
   private
     CONST StreamSignature: AnsiString= 'TChatPart';
   public
     ChatType : TChatType;
     Text     : string;      // Used if PartType is cptText.
     Path     : string;      // Our inpur file. Used if PartType is cptFileData.
     FileUri  : string;      // We get it from Gemini. Used if PartType is cptFileData (URI from "Gemini Files API"). If this is empty, we signal that there was a problem during upload. Example: 'https://generativelanguage.googleapis.com/v1beta/files/p684bj0vdbxj'
     Width    : integer;
     Height   : integer;     // Width and height of the original input image. Used if PartType is cptFile.

     procedure Load(Stream: TCubicBuffStream2); virtual;
     procedure Save(Stream: TCubicBuffStream2); virtual;
     constructor Create; virtual;
  end;


  TChatParts = class(TObjectList<TChatPart>)
   private
     CONST StreamSignature: AnsiString= 'TChatParts';
   public
     function FileExists(FileName: string): Boolean;

     procedure Load(Stream: TCubicBuffStream2);
     procedure Save(Stream: TCubicBuffStream2);
     procedure ReverseOrder;
  end;


function RoleToStr(ChatRole: TChatRole): string;


IMPLEMENTATION



constructor TChatPart.Create;
begin
  inherited;
end;




{-------------------------------------------------------------------------------------------------------------
   TChatPart
-------------------------------------------------------------------------------------------------------------}
procedure TChatPart.Load(Stream: TCubicBuffStream2);
begin
  Stream.ReadHeader(StreamSignature, 1);

  ChatType := TChatType(Stream.ReadInteger);
  Text     := Stream.ReadString;
  Path     := Stream.ReadString;
  FileUri  := Stream.ReadString;
  Width    := Stream.ReadInteger;
  Height   := Stream.ReadInteger;

  Stream.ReadPaddingE(4);
end;


procedure TChatPart.Save(Stream: TCubicBuffStream2);
begin
  Stream.WriteHeader(StreamSignature, 1);

  Stream.WriteInteger(Ord(ChatType));
  Stream.WriteString(Text);
  Stream.WriteString(Path);
  Stream.WriteString(FileUri);
  Stream.WriteInteger(Width);
  Stream.WriteInteger(Height);

  Stream.WritePadding(4);
end;



// Returns true if the specified file is already in the list
function TChatParts.FileExists(FileName: string): Boolean;
begin
  if Count = 0 then EXIT(FALSE);

  for VAR InputFile in Self do
    if SameFileName(InputFile.Path, FileName)
    then EXIT(TRUE);

  Result:= FALSE;
end;


{-------------------------------------------------------------------------------------------------------------
   TChatParts
-------------------------------------------------------------------------------------------------------------}
procedure TChatParts.ReverseOrder;
var
  i: Integer;
  TempList: TList<TChatPart>;
begin
  TempList := TList<TChatPart>.Create;
  try
    // Copy items in reverse order
    for i := Count - 1 downto 0 do
      TempList.Add(Self[i]);

    // Clear and refill InputFiles
    var OldValue := OwnsObjects;
    OwnsObjects := False;
    Clear;
    OwnsObjects := OldValue;

    for i := 0 to TempList.Count - 1 do
      Add(TempList[i]);
  finally
    FreeAndNil(TempList);
  end;
end;



{-------------------------------------------------------------------------------------------------------------
   IO
-------------------------------------------------------------------------------------------------------------}
procedure TChatParts.Load(Stream: TCubicBuffStream2);
VAR Version: Word;
begin
  if NOT Stream.ReadHeaderVersion(StreamSignature, Version) then EXIT;   // Header & version number

  var Total:= Stream.ReadInteger;
  for var i:= 1 to Total do
   begin
     var Obj:= TChatPart.Create;
     Obj.Load(Stream);
     Add(Obj);
   end;

  Stream.ReadPaddingE(12);
end;


procedure TChatParts.Save(Stream: TCubicBuffStream2);var Part: TChatPart;
begin
  Stream.WriteHeader(StreamSignature, 1);  // Header & version number

  Stream.WriteInteger(Count);
  for Part in Self do
    Part.Save(Stream);

  Stream.WritePadding(12);
end;





{-------------------------------------------------------------------------------------------------------------
   UTILS
-------------------------------------------------------------------------------------------------------------}
function RoleToStr(ChatRole: TChatRole): string;
begin
  case ChatRole of
    crUser: Result:= 'user';
    crModel: Result:= 'model';
    else RAISE Exception.Create('Unknown ChatRole!');
  end;
end;


end.

